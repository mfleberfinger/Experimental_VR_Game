using UnityEngine;
using System.Collections;

/// <summary>
/// A script that causes the gameobject to which it is attached to move forward
/// and turn, following a gradually changing, procedurally generated path.
/// </summary>
public class PathFollower : MonoBehaviour
{
	[Tooltip("Speed at which the path follower moves.")]
	public float speed = 10f;
	[Tooltip("Random number generator seed for path generation.")]
	public string seed = "seed";
	[Tooltip ("If true, the rotation of the object is controlled by this script.")]
	public bool controlRotation = true;
	[Tooltip("Seconds to wait before movement starts.")]
	public float startingDelay = 0f;
	[Tooltip("Maximum slope (as in \"rise over run\") of climb or descent (on the" +
		" y-axis) with respect to distance traveled on the xz-plane.")]
	public float maxSlope = 0.5f;

	// Object used to define and get points on the path.
	private PathGenerator pathGenerator;
	// Bool used to delay moving the follower.
	private bool started;
	// Imaginary fourth dimension used as a parameter to the path generator.
	// Can also be thought of as an arbitrary time based parameter.
	private float w;
	private Vector3 previousPosition, nextPosition;

	private void Start()
	{
		pathGenerator = new PathGenerator(seed);
		w = 0;
		// The follower is assumed to start at 0.
		transform.position = Vector3.zero;
		previousPosition = transform.position;
		nextPosition = transform.position;
	}

	
	private void Update()
	{
		if (started)
		{
			w = w + speed * Time.deltaTime;
			Move(w);
		}
		else
			started = Time.time > startingDelay;
	}

	/// <summary>
	/// Move the game object to which this is attached. Make sure it faces in
	/// the direction of travel.
	/// </summary>
	/// <param name="z">The w-coordinate to move to.</param>
	private void Move(float w)
	{
		// TODO: If using the physics engine, this will need to change.
		nextPosition = pathGenerator.GetPointWithLimitedSlope(w, previousPosition, maxSlope);
		// TODO: SMOOTH MOVEMENT. At the moment there is a lot of stuttering/vibration.
		//		using w to control speed is also reducing the resolution of the path
		//		generated by the Perlin noise function. Decouple path resolution and
		//		follower speed by increasing w by a constant step size and moving
		//		from one point to the next at a constant speed, regardless of how
		//		far apart they are.
		if (controlRotation)
			transform.LookAt(nextPosition);
		transform.position = nextPosition;
		previousPosition = nextPosition;
	}
}
